(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21009d"],{b5d8:function(n,e){n.exports='# 权限管理\n\n权限控制是中后台系统中常见的需求之一，你可以利用我们提供的 **路由权限** 和 **指令权限**，实现一些基本的权限控制功能，脚手架中也包含了几个简单示例以提供参考。\n\n\n\n## 路由和默认权限控制\n\nPro 提供了两套权限实现方案，其中默认方案为前端固定路由表和权限配置，由后端提供用户权限标识，来识别是否拥有该路由权限。另一套方案为后端提供权限和路由信息结构接口，动态生成权限和菜单。\n\n**默认实现方式**是通过获取当前用户的权限去比对路由表，生成当前用户具有的权限可访问的路由表，通过 `router.addRoutes` 动态挂载到 `router` 上。\n\n整体流程可以看这张图:\n![](/assets/router-permission.png)\n\n步骤如下:\n1. 判断是否有 `AccessToken` 如果没有则跳转到登录页面\n2. 获取用户信息和拥有权限`store.dispatch(\'GetInfo\')`\n3. 用户信息获取成功后, 调用 `store.dispatch(\'GenerateRoutes\', userInfo)` 根据获取到的用户信息构建出一个已经过滤好权限的路由结构(`src/store/modules/permission.js`) \n4. 将构建的路由结构信息利用 `Vue-Router` 提供的动态增加路由方法 `router.addRoutes` 加入到路由表中\n5. 加入路由表后将页面跳转到用户原始要访问的页面,如果没有 `redirect` 则进入默认页面 (`/dashboard/workplace`)\n\n> 这里可以看出把 `登录` 和 `获取用户信息` 分成了两个接口，主要目的在于当用户刷新页面时，可以根据登录时获取到的身份令牌（cookie/token）等，去获取用户信息，从而避免刷新需要调用登录接口\n>\n> Pro 实现的路由权限的控制代码都在 [@/permission.js](https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/permission.js) 中，如果想修改逻辑，直接在适当的判断逻辑中 `next()` 释放钩子即可。  \n> 两套权限实现 均使用 [@/permission.js](https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/permission.js) （路由守卫）来进行控制。\n\n\n\n## 动态路由\n\n但其实很多公司的业务逻辑可能并不是上面描述的简单实现方案，比如正常业务逻辑下 每个页面的信息都是动态从后端配置的，并不是像 Pro 默认的路由表那样写死在预设的。你可以在后台通过一个 tree 或者其它展现形式给每一个页面动态配置权限，之后将这份路由表存储到后端。\n权限/菜单 eg:\n![authority-management-permission-list](/assets/authority-p1.png)\n\n![authority-management-permission-object-info](/assets/authority-p3.png)\n\n角色 eg:\n![authority-management-roles-list](/assets/authority-p2.png)\n\n>  由 角色关联 到多个 权限(菜单) 。 __角色 1 对多权限__，__用户 1 对多角色__ 或 __用户 1 对 1 角色__；\n\n当用户登录后得到 roles，前端根据 roles 去向后端请求可访问的路由表，从而动态生成可访问页面，之后就是 `router.addRoutes` 动态挂载到 router 上，你会发现原来是相同的，万变不离其宗。\n\neg:\n```js\n// 后端返回的 JSON 动态路由结构\nconst servicePermissionMap = {\n"message": "",\n"result": [\n {\n   "title": "首页",\n   "key": "",\n   "name": "index",\n   "component": "BasicLayout",\n   "redirect": "/dashboard/workplace",\n   "children": [\n     {\n       "title": "仪表盘",\n       "key": "dashboard",\n       "component": "RouteView",\n       "icon": "dashboard",\n       "children": [\n         {\n           "title": "分析页",\n           "key": "analysis",\n           "icon": ""\n         },\n         ...\n       ]\n     },\n     {\n       "title": "系统管理",\n       "key": "system",\n       "component": "PageView",\n       "icon": "setting",\n       "children": [\n         {\n           "title": "用户管理",\n           "key": "userList"\n         },\n         ...\n       ]\n     }\n   ]\n }\n],\n"status": 200,\n"timestamp": 1534844188679\n}\n```\n\n```\nimport { axios } from \'@/utils/request\'\n// eslint-disable-next-line\nimport { UserLayout, BasicLayout, RouteView, BlankLayout, PageView } from \'@/layouts\'\n\n\n// 前端路由映射表\nconst constantRouterComponents = {\n  // 基础页面 layout 必须引入\n  BasicLayout: BasicLayout,\n  BlankLayout: BlankLayout,\n  RouteView: RouteView,\n  PageView: PageView,\n\n  // 你需要动态引入的页面组件\n  analysis: () => import(\'@/views/dashboard/Analysis\'),\n  workplace: () => import(\'@/views/dashboard/Workplace\'),\n  monitor: () => import(\'@/views/dashboard/Monitor\')\n  // ...more\n}\n\n// 前端未找到页面路由（固定不用改）\nconst notFoundRouter = {\n  path: \'*\', redirect: \'/404\', hidden: true\n}\n\n/**\n * 格式化 后端 结构信息并递归生成层级路由表\n *\n * @param routerMap\n * @param parent\n * @returns {*}\n */\nexport const generator = (routerMap, parent) => {\n  return routerMap.map(item => {\n    const currentRouter = {\n      // 路由地址 动态拼接生成如 /dashboard/workplace\n      path: `${parent && parent.path || \'\'}/${item.key}`,\n      // 路由名称，建议唯一\n      name: item.name || item.key || \'\',\n      // 该路由对应页面的 组件\n      component: constantRouterComponents[item.component || item.key],\n      // meta: 页面标题, 菜单图标, 页面权限(供指令权限用，可去掉)\n      meta: { title: item.title, icon: item.icon || undefined, permission: item.key && [ item.key ] || null }\n    }\n    // 为了防止出现后端返回结果不规范，处理有可能出现拼接出两个 反斜杠\n    currentRouter.path = currentRouter.path.replace(\'//\', \'/\')\n    // 重定向\n    item.redirect && (currentRouter.redirect = item.redirect)\n    // 是否有子菜单，并递归处理\n    if (item.children && item.children.length > 0) {\n      // Recursion\n      currentRouter.children = generator(item.children, currentRouter)\n    }\n    return currentRouter\n  })\n}\n```\n\n> 下方提供的链接可参考并理解其作用(2.0.3及以上版本中提供) \n> 方案2：\n> https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/router/generator-routers.js\n> https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/store/modules/async-router.js\n\n> 方案1：\n> \n> 需要注意的是，上面的代码只是一个例子，实际上可能更加复杂。需要开发者自身有一定的编码能力来实现动态路由功能。\n\n\n\n## 指令权限\n\nPro 封装了一个非常方便实现按钮级别权限的自定义指令。 [v-action](https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/core/directives/action.js)\n\n\n使用\n\n```vue\n\x3c!-- eg: 当前页面为 dashboard --\x3e\n\n<template>\n\t\x3c!-- 校验是否有 dashboard 权限下的 add 操作权限 --\x3e\n    <a-button v-action:add >添加用户</a-button>\n\n\t\x3c!-- 校验是否有 dashboard 权限下的 del 操作权限 --\x3e\n    <a-button v-action:del>删除用户</a-button>\n\n\t\x3c!-- 校验是否有 dashboard 权限下的 edit 操作权限 --\x3e\n    <a v-action:edit @click="edit(record)">修改</a>\n</template>\n```\n\n> 需要注意的是，指令权限默认从 store 中获取当前已经登陆的用户的角色和权限信息进行比对，所以也要对指令权限的获取和校验 Action 权限部分进行自定义。\n\n\n\n在某些情况下，不适合使用 `v-action`，例如 Tab 组件，只能通过手动设置 v-if 来实现。\n\n这时候，Pro 为其提供了原始 v-if 级别的权限判断。\n\n```vue\n<template>\n\t<a-tabs>\n        <a-tab-pane v-if="$auth(\'dashboard.add\')" tab="Tab 1">\n            some context..\n    \t</a-tab-pane>\n        <a-tab-pane v-if="$auth(\'dashboard.del\')" tab="Tab 2">\n            some context..\n    \t</a-tab-pane>\n        <a-tab-pane v-if="$auth(\'dashboard.edit\')" tab="Tab 3">\n            some context..\n    \t</a-tab-pane>\n    </a-tabs>\n</template>\n```\n> 以上代码的 if 判断会检查，当前登录用户是否存在 `dashboard` 下的  `add / del / edit` 权限\n\n实现思路：\n\n在 Vue 初始化时，[@/utils/helper/permission.js](https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/core/permission/permission.js#L17) 作为插件注册到 Vue 原型链上，在 Vue 实例中就可以用 this.$auth() 方法进行权限判断。 当然这里也要对权限的获取和校验 Action 权限部分进行自定义。\n'}}]);